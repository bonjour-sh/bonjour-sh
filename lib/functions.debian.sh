#!/bin/sh
#
# Debian-specific implementation for ./functions.sh

_package_resolve() (
    # See if a real package with this name exists
    _package_real=$(apt-cache show "$1" 2>/dev/null | awk '/^Package:/ { print $2; exit }')
    if [ -n "$_package_real" ]; then
        printf '%s' "$_package_real"
        return 0
    fi
    # Otherwise try resolving virtual packages
    _package_resolved=$(apt-cache showpkg "$1" 2>/dev/null | \
        awk '/^Reverse Provides:/ {found=1; next} found && NF { print $1; exit }')
    # If resolved, use that
    if [ -n "$_package_resolved" ]; then
        printf '%s' "$_package_resolved"
        return 0
    fi
    echo "Cannot resolve package ${1}" >&2
    return 1
)

_package() (
    case $1 in
        install)
            _quiet=
            if [ "$BONJOUR_DEBUG" ]; then
                _quiet='-q'
            fi
            _package_resolved=$(_package_resolve $2)
            [ "$BONJOUR_DEBUG" ] && echo "_package install ${2}/${_package_resolved}" >&2
            DEBIAN_FRONTEND=noninteractive apt-get install $_quiet \
                -y --no-install-recommends \
                -o Dpkg::Options::="--force-confnew" \
                "$_package_resolved"
            ;;
        purge)
            apt-get purge -y $2*
            ;;
        upgrade)
            apt-get upgrade -y
            ;;
        autoremove)
            apt-get autoremove -y
            ;;
    esac
)

# _at_boot - OS-agnostic wrapper to enable/disable a service at boot
# Depending on ACTION:
# - SERVICE starting up at boot will be enabled or disabled;
# - if ACT_IMMEDIATELY is true, SERVICE will be started or stopped immediately
# Usage: _at_boot ACTION SERVICE ACT_IMMEDIATELY
# Arguments:
#   $1 - ACTION: enable|disable
#   $2 - SERVICE: service name
#   $3 - ACT_IMMEDIATELY: true to start/stop (depending on ACTION) the service now
_at_boot() (
    case "$1" in
        'enable') update-rc.d "$2" defaults ;;
        'disable') update-rc.d -f "$2" remove ;;
    esac
    if [ "_$3" = "_true" ]; then
        service "$2" $( [ "_$1" = "_enable" ] && echo start || echo stop )
    fi
)

# _generate_rcd - make rc.d file for NAME using CMD_START and CMD_STOP
# Usage: _generate_rcd NAME CMD_START CMD_STOP
_generate_rcd() (
    cat > "/etc/init.d/${1}" <<-EOF
	#!/bin/sh
	### BEGIN INIT INFO
	# Provides:          ${1}
	# Required-Start:    \$network
	# Required-Stop:     \$network
	# Default-Start:     2 3 4 5
	# Default-Stop:      0 1 6
	# Short-Description: Starts ${1} after network is ready
	### END INIT INFO
	name="$1"
	cmd_start="$2"
	cmd_stop="$3"
	. "\$(bonjour env path)/lib/rc-d.sh"
	# Generated by _generate_rcd in bonjour-sh
	EOF
    # EOF above must be indented with 1 tab character
    chmod +x "/etc/init.d/${1}"
)

# _firewall - OS-agnostic wrapper to manage firewall
# Usage: _firewall RULE-NAME STATE SRC DIRECTION DST
# Arguments:
#   $1 - RULE-NAME: name for rule(set), used in filename for persisting
#   $2 - STATE: allow|deny|flush
#   $3 - SRC: see DST below
#   $4 - DIRECTION: in|out
#   $5 - DST: IP[/MASK][:PORT], e.g. 1.2.3.4, 1.2.3.4:56, 1.2.3.4/24:56 etc.
_firewall() (
    _file="/etc/iptables-bonjour/${1}.sh"
    # Determine target
    case $2 in
        allow)
            _target='ACCEPT'
            ;;
        deny)
            _target='DROP'
            ;;
        flush)
            : > "$_file"
            return
            ;;
    esac
    # Determine name of iptables chain we're working with
    [ "$4" = 'out' ] && _chain=OUTPUT || _chain=INPUT
    # Parse IP[/MASK] and PORT out of SRC and DST
    IFS=':' read -r _src_host _src_port <<-EOF
	$3
	EOF
    IFS=':' read -r _dst_host _dst_port <<-EOF
	$5
	EOF
    # EOFs above must be indented with 1 tab character
    # Build src line
    _src_line=''
    if [ -n "$_src_host" ]; then
        _src_line="${_src_line} -s ${_src_host}"
    fi
    if [ -n "$_src_port" ]; then
        _src_line="${_src_line} --sport ${_src_port}"
    fi
    _dst_line=''
    if [ -n "$_dst_host" ]; then
        _dst_line="${_dst_line} -d ${_dst_host}"
    fi
    if [ -n "$_dst_port" ]; then
        _dst_line="${_dst_line} --dport ${_dst_port}"
    fi
    $BONJOUR_DEBUG && cat >&2 <<-EOF
	    @          $@
	    file       $_file
	    chain      $_chain
	    src
	        host   $_src_host
	        port   $_src_port
	    dst
	        host   $_dst_host
	        port   $_dst_port
	EOF
    # EOF above must be indented with 1 tab character
    _rule="iptables -A ${_chain} -p tcp ${_src_line} ${_dst_line} -j ${_target}"
    _insert_once "$_rule" "$_file"
)
